---
layout: page
title: Metrics
---

Colossus uses the (currently nameless) metrics library.

## Introduction

High-throughput Colossus services can serve hundreds of thousands of requests
per second, which can easily translate to millions of recordable events per
second.  The Metrics library provides a way to work with metrics with as little
overhead as possible.

The metrics library performs 3 important operations

* **Event Collection** : providing a way for user-code to signal that something worth tracking has happened
* **Metrics Aggregation** : collecting raw events into metrics that can be filtered and aggregated in real-time
* **Reporting** : packaging up and sending data to some external database (such as OpenTSDB)


## Basic Architecture

The heart of metrics is a `MetricSystem`, which is a set of actors that handle
all of the background operations of dealing with metrics.  In most cases, you
only want to have one `MetricSystem` per application.

The entire flow of data happens in a pipeline

1.  Collection - application code signals an event to a collector
2.  Local Aggregation - event collectors within an actor produce a snapshot of their data
3.  Interval aggregation - local snapshots from all actors collecting metrics are periodically merged together into an interval snapshot
4.  Reporting - interval snapshots are pushed to reporters, which consume the snapshot and take action with the data

Everything happens asynchronously and the resulting data can be thought of as
eventually consistent.  

Every system has a configured set of tick intervals which determine how often
interval aggregations happens.  By default, aggregations happen both once per
second and once per minute, so two separate snapshots are produced.

### Event Collection

Event collection only happens inside an actor, it is not possible to directly
record events outside of one (although every collector has a shared interface,
see below).  Events, such as incrementing counters or adding values to
histograms, are always collected locally within an Akka actor.  So if you have
two actors recording the same metric, each actor will be collecting data
independantly.  This data is then periodically packaged up and shipped to a
central aggregator, which produces the final data.

In most cases, metrics are generated from various events triggered by
application code.  For example, we can keep track of a service's request rate
by firing an event every time a request finishes processing.  Likewise, we can
keep track of latency by adding the proccessing time of each request to a
histogram.

Event Collectors take the role of providing a simple API for generating events.

There are currently 4 built-in event collectors:

* Counter - keeps track of a single number which can process increment/decrement operations
* Rate - A rate can be "hit" and it will track hits/second (or other time periods)
* Histogram - Similar to a rate, but each hit includes an integer value.  The histogram will generate percentiles/min/max over periods of time
* Gauge - set a static integer value

Each metric has numerous configuration options to ensure the best measurements for the job.

### Aggregation Intervals

Aggregation intervals define how often the raw data from all event collectors
are snapshotted and merged together into a single database of values.

By default, a metric system is created with both 1 second and 1 minute
aggregation intervals.  The idea here is the 1 second interval is used to show
real-time metrics where rates and histograms are all showing values reflective
of the last second of activity, whereas the 1 minute intervals are used for
reporting values to an external database in which case the values reported are
all reflective of the last minute of activity.


### Structure of a Metric

Regardless of whether the event collector is a rate, counter, etc, the
resulting data it produces is one or more metrics.  A metric is simply a set of
integer values.

Every metric in a system has a unique name with a url-like structure.  For
example, `/my-service/requests` and `/my-service/system/gc/msec` are two
metrics automatically generated by Colossus.  Every metric contains a set of
integer values, with each value uniquely identified by a set of key/value tags.
For example, the values for the `system/gc/msec` metric might look like

{% highlight scala %}

/my-service/system/gc/msec
  [type = ParNew] : 123456
  [type = ConcurrentMarkSweep] : 9876543


{% endhighlight %}

Tags are immensely useful when more fine-grained breakdown of imformation is
required.  A metric value can have multiple tags, values in a single metric do
not all need the same tags, and tags are optional.  We will see later that tags
can also be used to filter and aggregate values.

For example, suppose we have a rate to track the processing frequency of some task, we might have code that looks like 

{% highlight scala %}
val rate = metrics getOrAdd Rate("/my-rate")

//...
def processData(data: Foo) {
  if (data.isValid) {
    rate.hit(Map("valid" -> "true"))
  } else {
    rate.hit(Map("valid" -> "false"))
  }
}
{% endhighlight %}

The map that's passed in as a parameter is a `TagMap`, which allows you to
associate a set of tags with the event.  This code could be running in parallel
inside multiple actors, but the end result is going to be a single metric that
looks like:

    /my-rate
      [valid: true] 46383422
      [valid: false] 2499

You can then run queries on the data such as:

```
SELECT /my-rate WHERE valid=true
```

```
SELECT /my-rate GROUP BY * SUM
```

So one value will exist per unique `TagMap`.  The number of values per metric can quickly grow to a large number.  For example, suppose our data has an associated name, then our code might look like:

{% highlight scala %}
def processData(data: Foo) {
  if (data.isValid) {
    rate.hit(Map("valid" -> "true", "name" -> data.name))
  } else {
    rate.hit(Map("valid" -> "false", "name -> data.name))
  }
}
{% endhighlight %}

Now our resulting metric could have many more values: 

    /my-rate
      [valid: true, name: bar] 252
      [valid: false, name: bar] 2499
      [valid: true, name: baz] 3452
      [valid: false, name: bar] 9852

Of course, using tags at all is completely optional, so it is entirely up to you to determine what tags should be used for a specific metric

## Getting Started

If you are using colossus, it depends on the metrics library and pulls it in.  Otherwise you must add the following to your build.sbt/Build.scala

{% highlight scala %}

libraryDependencies += "com.tumblr" %% "colossus-metrics" % "{{ site.latest_version }}"

{% endhighlight %}

From there, the only required step is to spin up a `MetricSystem`

{% highlight scala %}

import akka.actor._
import metrics._
import scala.concurrent.duration._

implicit val actor_system = ActorSystem()

//create the metric system
val metric_system = MetricSystem("/my-service")

{% endhighlight %}



### Quickstart : Local Collection

Colossus-metrics is intended to be used inside actors, and the most efficient way to record metrics is to mixin the `ActorMetrics` trait:

{% highlight scala %}

class MyActor(val metricSystem: MetricSystem) extends Actor with ActorMetrics {

  //the trait automatically creates a LocalCollection called metrics  
  val rate = metrics getOrAdd Rate("/foos")

  def receive = handleMetrics orElse {
    case "Foo" => {
      rate.hit()
    }
    case "Bar" => {
      //DO NOT DO THIS
      Future {
        rate.hit()
      }
    }
  }

}

{% endhighlight %}

It's important to ensure you compose `handleMetrics` into all of your Receives.


### Quickstart : Shared Collection

In some cases you might want to record metrics from outside of an actor, or for
some other reason don't want to mixin the `ActorMetrics` trait.  In these
cases, you can use a `SharedCollection` which returns thread-safe versions of
all the event collectors.  The one caveat is that every event is really an
actor message, so the overhead of using a shared rate is much higher than that
of a local rate.

{% highlight scala %}

//get a collection
val collection = metric_system.sharedCollection

//now get a rate from the collection
val rate = collection getOrAdd Rate("/my-rate", periods = List(1.second, 1.minute))

//fire off some events!
rate.hit()
rate.hit(25)

//metrics returned by the shared collection are thread safe
Future {
  rate.hit()
}

//arbitary maps of tags can be included with any event
rate.hit(tags = Map("key" -> "value"))

{% endhighlight %}



### Using metrics within Colossus

Being an actor, a Colossus event loop has it's own `LocalCollection`.  This can be accessed through `context.worker.metrics`, for example:

{% highlight scala %}

Service.serve[Http]("my-service", 80) { context =>
  val myRate = context.worker.metrics.getOrAdd(Rate("my-rate"))
  context.handle{ connection =>
    connection.become{
      case request @ Get on Root / "hit" => {
        myRate.hit()
        request.ok("ok!")
      }
    }
  }
}

{% endhighlight %}

## Metric Reporting

Currently metric reporting is mostly focused on reporting to OpenTSDB.  To setup reporting you basically need 2 things:

* A MetricSender - this is the object that encodes metrics to be sent
* A set of metric filters - These are used to select and aggregate which metrics to send

In addition to OpenTSDB, metrics may also be logged to file. To use logging, change the MetricSystem to use
a LoggingSender as the metrics reporter:

{% highlight scala %}

import akka.actor._
import metrics._
import scala.concurrent.duration._

implicit val actor_system = ActorSystem()

//create the metric system
val metric_system = MetricSystem("/my-service")

//create the config, providing LoggerSender as the MetricSender
val metric_config = MetricReporterConfig(LoggerSender)

//set this as the reporting for the metric system
metric_system.metricIntervals(1.minute).report(metric_config)

//get a collection
val collection = metric_system.sharedCollection

//proceed as normal

{% endhighlight %}


