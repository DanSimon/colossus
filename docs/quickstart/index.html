<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Quickstart</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="Colossus IO Framework: Built at Tumblr">
    <link rel="canonical" href="https://github.com/tumblr/colossus/pages/tumblr/colossus/docs/quickstart/">

    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <meta http-equiv="imagetoolbar" content="no" />
    <link rel="stylesheet" href="/pages/tumblr/colossus/css/layout.css" type="text/css" />
    <script type="text/javascript" src="/pages/tumblr/colossus/js/jquery.js"></script>
    <script type="text/javascript" src="/pages/tumblr/colossus/js/jquery.innerfade.js"></script>

</head>

</head>


    <body>

    <div class="wrapper col1">
  <div id="header">
    <div id="logo">
      <h1><a href="/pages/tumblr/colossus/">Colossus</a></h1>
    </div>
    <div id="topnav">
      <ul>
        <li><a href="/pages/tumblr/colossus/about">About</a></li>
        <li><a href="/pages/tumblr/colossus/">Community</a></li>
        <li><a href="/pages/tumblr/colossus/docs">Documentation</a></li>
        <li><a href="https://github.com/tumblr/colossus">Github</a></li>
      </ul>
    </div>
    <br class="clear" />
  <p class="breaking-news"><b>Notice</b>: These docs are a work in progress.  If you see an error, <a href="https://github.ewr01.tumblr.net/Tumblr/teamscala/tree/gh-pages-source">fix it</a>!</p>
  </div>
</div>



        <div class="wrapper col3">
    <div id="container">
      <header class="post-header">
        <h1>Quickstart</h1>
      </header>
      <div id="content">
        <article class="post-content">
        <p>Hey there, thanks for taking a look!  This quickstart is designed to give a
brief introduction to some of the central features of Colossus and show what
it’s like to work with the framework.</p>

<p>This guide covers the primary focus of Colossus, building services.  A
<strong>service</strong> is a server that reads requests from clients and processes them
into responses to send back.  Clients can send multiple requests at the same
time, many (thousands of) clients can be connected to a server at the same
time, and request processing is expected to happen in parallel.  Colossus does
all that and more.</p>

<p>This quickstart assumes you are familiar with developing Scala applications
using SBT.  Furthermore you should be generally familiar with Akka and
concurrent programming concepts.</p>

<h2 id="sbt">SBT</h2>
<p>Add the following to your Build.scala or build.sbt:</p>

<div class="highlight"><pre><code class="scala"><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"com.tumblr"</span> <span class="o">%%</span> <span class="s">"colossus"</span> <span class="o">%</span> <span class="s">"0.5.0-RC3"</span></code></pre></div>

<p>Colossus is compiled for Scala 2.10 and 2.11 and built against Akka 2.3.</p>

<h2 id="build-a-hello-world-service">Build a Hello World Service</h2>

<p><em>If you’re feeling particularly opposed to copy/paste, clone the <a href="https://github.ewr01.tumblr.net/dan/colossus-template">template project</a></em></p>

<p>In a standard SBT project layout, create <code>Main.scala</code>.  Add this to it:</p>

<div class="highlight"><pre><code class="scala"><span class="k">import</span> <span class="nn">colossus._</span>
<span class="k">import</span> <span class="nn">service._</span>
<span class="k">import</span> <span class="nn">protocols.telnet._</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IOSystem</span><span class="o">()</span>

  <span class="nc">Service</span><span class="o">.</span><span class="n">become</span><span class="o">[</span><span class="kt">Telnet</span><span class="o">](</span><span class="s">"hello-world"</span> <span class="o">,</span> <span class="mi">10010</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">TelnetCommand</span><span class="o">(</span><span class="s">"exit"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">TelnetReply</span><span class="o">(</span><span class="s">"Bye!"</span><span class="o">).</span><span class="n">onWrite</span><span class="o">(</span><span class="nc">OnWriteAction</span><span class="o">.</span><span class="nc">Disconnect</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">TelnetCommand</span><span class="o">(</span><span class="s">"say"</span> <span class="o">::</span> <span class="n">text</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">TelnetReply</span><span class="o">(</span><span class="n">text</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span> <span class="nc">TelnetReply</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span></code></pre></div>

<p>Now when you run your application, you should be able to connect to the server with any standard telnet client.</p>

<div class="highlight"><pre><code class="plaintext">&gt; telnet localhost 10010
Trying ::1...
Connected to localhost.
Escape character is '^]'.
&gt; hello
TelnetCommand(List(hello))
&gt; say "I am a teapot"
I am a teapot
&gt; exit
Bye!
Connection closed by foreign host.</code></pre></div>

<h3 id="a-closer-look">A Closer Look</h3>

<p>Let’s look at this service line-by-line.</p>

<div class="highlight"><pre><code class="scala"><span class="k">implicit</span> <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IOSystem</span><span class="o">()</span></code></pre></div>

<p>The first thing you have to do when starting any Colossus service is to create
an <code>IOSystem</code>.  The <code>IOSystem</code> is a collection of event loops with a thin
management layer on top.  Both Servers and clients can be attached to an
<code>IOSystem</code>, which by default will start one event-loop per physical CPU core.
Internally, an <code>IOSystem</code> is just a bunch of Akka actors, and in this context
the <code>IOSystem</code> will create its own Akka <code>ActorSystem</code>, but you can also attach
it to an existing <code>ActorSystem</code>.</p>

<p>In the case of a server like our service, all of the event loops in the
<code>IOSystem</code> will be used, with incoming connections being round-robin’d across
them.  This means that overall our service is multi-threaded, but all our code
interacting with a particular connection is single-threaded (at least so far).</p>

<p>We defined the <code>IOSystem</code> as <code>implicit</code> becuase it is a dependency for the next
line, which is where we actually spin up our service:</p>

<div class="highlight"><pre><code class="scala"><span class="nc">Service</span><span class="o">.</span><span class="n">become</span><span class="o">[</span><span class="kt">Telnet</span><span class="o">](</span><span class="s">"hello-world"</span> <span class="o">,</span> <span class="mi">10010</span><span class="o">)</span> <span class="o">{</span></code></pre></div>

<p>This is using the Service functional DSL to start a server on port 10010 using
the telnet protocol.  Every service is built around a protocol using a
<strong>codec</strong>.  Codecs do the job of turning raw incoming bytes into immutable
request objects, and vise versa for turning response objects into raw bytes.
So for the telnet protocol, your service only has to worry about taking a
<code>TelnetCommand</code> and turning it into a <code>TelnetReply</code>.</p>

<p><code>Service.become</code> is the simplest form of starting a service, and requires a
pattern-matching expression as its body.  This is perfect for simple, stateless
services like this one, but there are other methods avaiable for more
sophisticated situations.</p>

<p>This brings us to the actual logic of the service:</p>

<div class="highlight"><pre><code class="scala"><span class="k">case</span> <span class="nc">TelnetCommand</span><span class="o">(</span><span class="s">"exit"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">TelnetReply</span><span class="o">(</span><span class="s">"Bye!"</span><span class="o">).</span><span class="n">onWrite</span><span class="o">(</span><span class="nc">OnWriteAction</span><span class="o">.</span><span class="nc">Disconnect</span><span class="o">)</span>
<span class="k">case</span> <span class="nc">TelnetCommand</span><span class="o">(</span><span class="s">"say"</span> <span class="o">::</span> <span class="n">text</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">TelnetReply</span><span class="o">(</span><span class="n">text</span><span class="o">)</span>
<span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span> <span class="nc">TelnetReply</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span></code></pre></div>

<p>This is mostly just standard pattern matching against a <code>TelnetCommand</code>, producing a
<code>TelnetReply</code> for each case.  The one interesting thing to point out here is this one part:</p>

<div class="highlight"><pre><code class="scala"><span class="nc">TelnetReply</span><span class="o">(</span><span class="s">"Bye!"</span><span class="o">).</span><span class="n">onWrite</span><span class="o">(</span><span class="nc">OnWriteAction</span><span class="o">.</span><span class="nc">Disconnect</span><span class="o">)</span></code></pre></div>

<p><code>onWrite</code> is not a method of <code>TelnetReply</code>, but actually we are uising Scala’s
type-lifting pattern to lift the <code>TelnetReply</code> into a
<code>Completion[TelnetReply]</code>, which lets us attach metadata and some other things
to our response object.  This way we can tell Colossus to terminate the
connection after writing this response, without having to block or deal with
callbacks.</p>

<h2 id="lets-get-hacking">Let’s get Hacking</h2>

<p>Writing a service in ~5 lines of code is pretty neat, but obviously this
example is artifically simple and doesn’t really illustrate the real power of
Colossus.  Let’s try doing something a little more interesting, such as writing
a http interface to a redis server.</p>

<h3 id="writing-the-http-service">Writing the Http service</h3>

<p>So we want to build a service that starts an http server and also connects to a
redis database.  First let’s create a skeleton service using the http protocol:</p>

<div class="highlight"><pre><code class="scala"><span class="k">import</span> <span class="nn">protocols.http._</span>
<span class="k">import</span> <span class="nn">HttpMethod._</span>
<span class="k">import</span> <span class="nn">UrlParsing._</span>

<span class="nc">Service</span><span class="o">.</span><span class="n">serve</span><span class="o">[</span><span class="kt">Http</span><span class="o">](</span><span class="s">"http-service"</span><span class="o">,</span> <span class="mi">9000</span><span class="o">){</span> <span class="n">context</span> <span class="k">=&gt;</span>
  <span class="n">context</span><span class="o">.</span><span class="n">handle</span><span class="o">{</span> <span class="n">connection</span> <span class="k">=&gt;</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">become</span><span class="o">{</span>
      <span class="k">case</span> <span class="n">request</span> <span class="k">@</span> <span class="nc">Get</span> <span class="n">on</span> <span class="nc">Root</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">.</span><span class="n">ok</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>Now we’re using <code>Service.serve</code> instead of <code>Service.become</code>.  What’s the
difference, and what’s with the nested functions?  The goal here is we need an
outgoing connection to Redis, which brings us to the first law of Colossus, <em>Do
not share state between event loops</em>.  This means, if we wish to connect to
redis, then we will open one connection per event loop.  Every http connection bound
to a particular event loop will share the same redis connection, which is totally fine
since event loops themselves are single-threaded.</p>

<p><code>Service.serve</code> gives us a place to add initialization code per event loop.
This way we can create the redis connection and it’ll simply be in scope for
our pattern matching.  So let’s create the connection.</p>

<div class="highlight"><pre><code class="scala"><span class="k">import</span> <span class="nn">protocols.redis._</span>

<span class="nc">Service</span><span class="o">.</span><span class="n">serve</span><span class="o">[</span><span class="kt">Http</span><span class="o">](</span><span class="s">"http-service"</span><span class="o">,</span> <span class="mi">9000</span><span class="o">){</span> <span class="n">context</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">redis</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">clientFor</span><span class="o">[</span><span class="kt">Redis</span><span class="o">](</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">6379</span><span class="o">)</span>
  <span class="o">//...</span></code></pre></div>

<p>So on a computer with 4 cores, this code will end up opening 4 connections to
redis.  Here we’re using the default config, but clients have a ton of
configuration options such as setting various buffer sizes and failure logic.
Also like servers, clients have metrics such as request rate and latency
built-in.</p>

<p>So all together now, along with some dummy routes for get/set on keys:</p>

<div class="highlight"><pre><code class="scala"><span class="k">implicit</span> <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IOSystem</span><span class="o">()</span>

<span class="nc">Service</span><span class="o">.</span><span class="n">serve</span><span class="o">[</span><span class="kt">Http</span><span class="o">](</span><span class="s">"http-service"</span><span class="o">,</span> <span class="mi">9000</span><span class="o">){</span> <span class="n">context</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">redis</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">clientFor</span><span class="o">[</span><span class="kt">Redis</span><span class="o">](</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">6379</span><span class="o">)</span>
  <span class="n">context</span><span class="o">.</span><span class="n">handle</span><span class="o">{</span> <span class="n">connection</span> <span class="k">=&gt;</span> 
    <span class="n">connection</span><span class="o">.</span><span class="n">become</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">request</span> <span class="k">@</span> <span class="nc">Get</span> <span class="n">on</span> <span class="nc">Root</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">.</span><span class="n">ok</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">request</span> <span class="k">@</span> <span class="nc">Get</span> <span class="n">on</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"get"</span> <span class="o">/</span> <span class="n">key</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">.</span><span class="n">notImplemented</span><span class="o">(</span><span class="s">"soooon"</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">request</span> <span class="k">@</span> <span class="nc">Get</span> <span class="n">on</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"set"</span> <span class="o">/</span> <span class="n">key</span> <span class="o">/</span> <span class="n">value</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">.</span><span class="n">notImplemented</span><span class="o">(</span><span class="s">"soooon"</span><span class="o">)</span>
      <span class="c1">//anything that falls through the partial function gets turned into a 404 error
</span>    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>So now let’s fill in our get route.  Using the redis client is easy:</p>

<div class="highlight"><pre><code class="scala"><span class="k">case</span> <span class="n">request</span> <span class="k">@</span> <span class="nc">Get</span> <span class="n">on</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"get"</span> <span class="o">/</span> <span class="n">key</span> <span class="k">=&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="nc">Commands</span><span class="o">.</span><span class="nc">Get</span><span class="o">(</span><span class="n">key</span><span class="o">)).</span><span class="n">map</span><span class="o">{</span>
  <span class="k">case</span> <span class="nc">BulkReply</span><span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">.</span><span class="n">ok</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="n">utf8String</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">NilReply</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">.</span><span class="n">notFound</span><span class="o">(</span><span class="s">"(nil)"</span><span class="o">)</span>
<span class="o">}</span></code></pre></div>

<p>This is where things get interesting.  We’re sending a <code>GET</code> command to redis
for the key, and mapping on the response.  If you’ve done concurrent
programming in Scala before, this looks a lot like working with a Future, but
that’s not the case here, <code>redis.send</code> is returning a type <code>Callback[Reply]</code>.
A <strong>Callback</strong> in Colossus behaves very similarly to a Future, but a callback
works entirely in-thread, so even though the above code is non-blocking, it is
also entirely single-threaded.  For the most part, Callbacks have the same
interface as Futures, including <code>flatMap</code> and <code>recover</code> methods.</p>

<p>Callbacks are the secret sauce that allow Colossus to achieve such low latency
for small, stateless requests like these.  Since both our http connection and
our redis connection live in the same event loop, there’s no reason to use a
Future that is designed to work across threads.  The small overhead they need
to run inside an <code>ExecutionContext</code> is overkill in this situation.</p>

<p>Callbacks are not meant to replace Futures, in fact the only place they are
used in Colossus is this particular situation where you need to get data from
one connection to another without jumping out of the event loop.  But in the
world of microservices this is basically the most common thing that happens, so
using Callbacks has a significant impact on performance.</p>

<p>Implementing the <code>Set</code> route is similar:</p>

<div class="highlight"><pre><code class="scala"><span class="k">case</span> <span class="n">request</span> <span class="k">@</span> <span class="nc">Get</span> <span class="n">on</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"set"</span> <span class="o">/</span> <span class="n">key</span> <span class="o">/</span> <span class="n">value</span> <span class="k">=&gt;</span> <span class="n">redis</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="nc">Commands</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)).</span><span class="n">map</span><span class="o">{</span>
  <span class="k">case</span> <span class="nc">StatusReply</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">.</span><span class="n">ok</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
<span class="o">}</span></code></pre></div>

<p>And there we have it, a fully functional service with almost no boilerplate.</p>

<h3 id="where-to-go-from-here">Where to go from here</h3>

<p>The rest of docs provide more detail about how all this works and how to
leverage more advanced features, particularly the section on <a href="../serviceserver">building a
service server</a>.  Also be sure to check out the 
<a href="https://github.com/tumblr/colossus/tree/master/colossus-examples/src/main/scala/colossus-examples">examples</a> sub-project in the Colossus repo.</p>


        </article>
      </div>
      <div id="column">
        <div class="subnav">
          <ol class="toc"><li><a href="#sbt">SBT</a></li><li><a href="#build-a-hello-world-service">Build a Hello World Service</a></li><li><a href="#lets-get-hacking">Let’s get Hacking</a></li></ol>
        </div>
      </div>
      <br class="clear" />
    </div>
  </div>
  <br class="clear" />



    <footer id = "footer" class="site-footer">

<div class="wrapper col5">
  <div id="copyright">
    <p class="fl_left">Copyright &copy; 2014 Tumblr - All Rights Reserved <a rel="license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/3.0/80x15.png" /></a></p>
    <p class="fl_right">Based on a template by <a href="http://www.os-templates.com/" title="Free Website Templates">OS Templates</a></p>
    <br class="clear" />
  </div>
</div>

</footer>


    </body>
</html>
